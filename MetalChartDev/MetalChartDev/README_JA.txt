

このMCKitはiOS 8で導入されたMetal APIを使用したグラフライブラリである.


1. モチベーション

アプリ開発をしていく上で、グラフ表示の必要に迫られる機会は多い。
その際の実装方法の選択肢は以下のようなものになるだろう。

(1) CoreGraphics APIを使って、必要な機能に対して最小のコードで実装する（当然ライブラリとしては再利用できない）
(2) 上記をより拡張して、ライブラリとして再利用可能にしたものを作成する
(3) 上記２つのようなコードを、既存のプロジェクトから（場合によっては半ば無理やり）持ってくる
(4) 外部から成熟したライブラリを持ってくる

時間的な余裕が無い場合は、(3)か(4)の選択を迫られる。
よほど腕の良いプログラマが余裕をもって担当したのでなければ、多くは(3)の選択が悲惨な結果へ導く確率は高いと考える。
そして(4)を選択する。

私はShinobiChartを使う機会が多かった。
確かにグラフを導入するための足がかりとしては十分で、パフォーマンスも悪くはない。
機能も豊富で全て自分でコードを書く場合と比べれば、開発時間は圧倒的に短くできる。

しかしインタフェース設計の観点から見た時、私はShinobiChartのそれは端的に言って稚拙だと思っている。
具体的な不満をいくつか挙げてみよう

・一つのクラスが持つプロパティが多すぎて、そのクラスが表すモデルがイメージできない（SCAxisなどは顕著である）
　整理されていなくて、ひどく「泥臭く」感じる.
・クラスの理想的な振る舞いが明確でないため、実装が変わった時に挙動が変化する事がある
・上記に加えてドキュメンテーションが不足しており、細かい設定をするためには試行錯誤を必要とする
・いろんな事ができるが、どちらかといえば「器用貧乏」でかゆい所には手が届かない
・データソース、デリゲートを採用する事によるデメリットと見合うだけのメリットが感じられない
・不正な使い方をするとabortする（特にSCAxis周りで誰もが経験した事があるだろう）が、
　使い方の正誤をインタフェースが全く示唆していない事がそもそもの原因である
・インタフェースでプロトコルを使用して「カスタマイズ可能」を謳っている箇所のうちかなりの部分が、
　正確なドキュメンテーションがなく、既存の実装も見れないため、実際には独自実装できない

ShinobiChartで実装されている機能はかなり多岐にわたるが、大抵の場合、使う機能はほんの一部である。
そしてその一部の機能を使い込んでいく時、上記の不満が噴出する。
例えばプロット領域の拡大縮小・移動機能を調整しようとして、思った通りに動かす事ができず、悲鳴を上げた事のある人は多いはずだ。
一体全体、軸の範囲（というよりもデータ空間からビュー空間への写像）がデータ依存で勝手に更新されたり、
それを防ぐためにプロパティをいじると別の効果が併発したり、そもそもこう言った機能がプロトコル化されていない必須のSCAxis内で
全部実装されていたり、何を考えているのか小一時間問い詰めたい気持ちにかられるのも無理はない。
（min/maxを返すデリゲートを使えばそれで済む話じゃないか！え？それじゃユーザ操作が考慮できないって？
　それこそユーザ操作をView側で全部処理せず、UIGestureRecognizerを使ってスケールと移動量を
　別の経路で取れるようにすれば済む話だ！）
これは機能するようにしただけであって、インタフェースで問題を整理することができていないからだ。

まぁ色々と書いてしまったが、結局の所、「ぼくのかんがえたさいきょうのグラフライブラリ」を、Metalを使って
実装してみたいという欲求が、このライブラリを作成するに至った動機である。


2. 設計目標

(1) インタフェースがそれ自体で挙動を表す事（値の解釈など、どうしても必要な場合を除く）
(2) 効率的である事
(3) 可能な限りプロトコルを使用し、依存を強制されるクラスを最小に抑え、独自実装クラスによる代替を可能とする事


3. 概念モデル

ライブラリ内でプロトコル化されていない、必ず使用する必要のあるクラスはほぼ全て「コアクラス」として MCChart.h に宣言されている。
（ほぼ、と書いたのは、これらの中に内部的にシェーダで使用する構造体のバッファを保持するものが含まれるためである）
概念はシンプルで、
(1) データ空間からビュー空間への写像を定義するクラス群
(2) 紐付けた写像を受け取って描画するメソッドを定義するプロトコル
(3) 画面に追加で描画できるアタッチメントのためのプロトコル
(4) ComputeShaderを含む、フレーム描画ルーチン内で実行したいコードを挿入するためのプロトコル
(5) それらを管理するコンテナとしてのMetalChartクラス
で構成されている。
つまる所、メインはデータ空間・写像・コンテナである。

折れ線などのデータ系列は(2)を実装し、軸やプロット領域背景は(3)、アニメーションは(4)を通して実装されている。

4. 補足事項

4.1 範囲制御について

写像（表示範囲）の制御に関して、コアクラスでは一切の制約を加えない。
(1)のクラス自体がフラグなどを全く持たず、能動的にはほぼ何もしない、ほぼPlainなオブジェクト（ただしバッファへの書き込みを行う）だからである。
これは「画面表示はどの値に基づいているのか」をシンプルにするために必須である。複雑なロジックはオブジェクトを操作するためのロジックとして定義されるべきである。
そのため、データやユーザ操作に応じて範囲を制御するための手段は、切り離されたクラス(MCProjectionUpdater)として定義されている。

このMCProjectionUpdaterは複数のMCRestrictions（長さ制限、データ欠損時のデフォルト値、データに対するパディングの付加等）を
パイプライン状につなげて１軸の表示範囲(MCDimensionalProjection)を決定する。そしてこのクラスに、ユーザの操作を反映するためのRestrictionを追加することで
Panning等の操作を可能にしている。

また、移動量などのステートはRestriction自体ではなく、管理用のクラス(MCGestureInterpreter)が保持し、それを参照するようになっている。
ただし、MCProjectionUpdaterは外部から指示されない限りは範囲をアップデートしない（すべきでない）ため、MCInteractionプロトコルと
ブロック実装クラスを用いて、ステート変更時にトリガーしてやる必要がある。

このあたりの煩雑な手続きは、
[MCSimpleBlockInteraction connectUpdaters: toInterpreter: orientations]
で省略できる.

4.2 軸ラベルの既存実装に関して

・既存実装のMCAxisLabel は CoreText -> CGBitmapContext -> MTLTexture -> 四角形　という形で実装されている.
　そのため利用にはCoreText、CoreGraphicsが必要である。

・当該実装を可能にするための仕組みはコアクラスには存在していないため、MCAxisへの付加機能として実装した。

・必須の機能でないものをデフォルトで強要するのはポリシーに反する（かつ描画バッファサイズの問題もあり、難しい）ので手動設定を必要とする。

・全てのラベルが毎フレーム更新されるような場合（普通はないが、ユーザ操作等でメモリ位置がずれる場合）CPUにそこそこの負荷がかかるため、
　機種やその他負荷によっては60fpsを切る可能性がある。折れ線等他のパーツは点数が増えてもGPU負荷が増えるだけなので競合はしないが、
　そういった設定は可能ならば避けるべきである。



