

このFMKitはiOS 8で導入されたMetal APIを使用したグラフライブラリである.
機能は制限されるが、データ数（点数）4K以下のほぼ全ての場合において、60fps実行を可能とする.
また同時に、再描画の必要がない場合のCPU負荷を0にすることも(60fpsを保ちながら)可能である.
インタフェース設計に関しても、差し替え可能な幾つかのコンポーネント群と、それらを使いやすくするための
ラッパとに分けて用意してあり、最大限まで利用者がコントロールできるような余地を残してある.

ただしライブラリの目標上、少数のデータを大いに装飾して可視化するための機能は少なく、そういった機能が欲しい場合は
別のライブラリを使う（か独自に機能追加する）事が手軽と思われる.




1. モチベーション

グラフ描画というのは、やってみると思うより難しい.
大体の人はグラフライブラリを使う事だけを考えると思う.
私は仕事上あるChartingフレームワークに触れている時間が長かった.
まだ経験の浅かった頃に初めて触った時、そのフレームワークは良くできているように思えた.
しかし今では、インタフェースの出来の悪さとそこから来るパフォーマンス上の悪さ（ひどくはない、ただし良くもない）にうんざりしている.

問題だったのは、以下の様な事柄だった：
・意味もなくDatasourceプロトコルを使っている（グラフで恩恵を得る事ができるのは、原理的に行ってごく一部のケースだけだ）
　結果として複数のデータを重ねて表示する様な場合、却ってコードの見通しが悪くなりがちだった.
・データを少し追加したいだけで全てのデータがリロード、それもデータ点毎のオブジェクト生成が要求される
・データの内容によって表示範囲（データ空間でのrange）が勝手に調整されたり、動かせる範囲が変わったり、
　Barの太さが変わったりする. 自動調整が悪いとは言わないが、最低でもインタフェースを整理してDelegateに
　移譲できるようにすべきである.
・上の問題への対処がプロパティを増やす事でなされる為、オブジェクトが複雑になりすぎる

一言でまとめるなら、「そんな事は頼んでない、伝えた事だけやってくれ！」という気持ちを抑えられなくなったのだ.
この時点で、自分の欲しいグラフライブラリの形が見えた.

・余計な事をしない
・漠然としたセマンティクスに基づいたクラス設計をしない
・毎フレームのCPU処理は最低限に抑え、基本はstateに基づいてレンダリングするだけにとどめる.
・できる事は全部シェーダでやる

タイミング的にLow Overhead Graphics APIが出てきていた事もあり、Metalで実装しようと思い立った.




2. 設計目標

(1) インタフェースがそれ自体で挙動を表す事（値の解釈など、どうしても必要な場合を除く）
(2) 効率的である事
(3) 可能な限りプロトコルを使用し、依存を強制されるクラスを最小に抑え、独自実装クラスによる代替を可能とする事




3. 概念モデル

ライブラリ内でプロトコル化されていない、必ず使用する必要のあるクラスはほぼ全て「コアクラス」として FMChart.h に宣言されている。
（ほぼ、と書いたのは、これらの中に内部的にシェーダで使用する構造体のバッファを保持するものが含まれるためである）
概念はシンプルで、
(1) データ空間からビュー空間への写像を定義するクラス群
(2) 紐付けた写像を受け取って描画するメソッドを定義するプロトコル
(3) 画面に追加で描画できるアタッチメントのためのプロトコル
(4) ComputeShaderを含む、フレーム描画ルーチン内で実行したいコードを挿入するためのプロトコル
(5) それらを管理するコンテナとしてのMetalChartクラス
で構成されている。
つまる所、メインはデータ空間・写像・コンテナである。

折れ線などのデータ系列は(2)を実装し、軸やプロット領域背景は(3)、アニメーションは(4)を通して実装されている。
ただし、これらのコアクラス・プロトコル中にデータの持ち方に関する規定は含まれない。自分で拡張する際、再利用する事も可能だが
自分ですべて決める事もできる.




4. まずやるべき事

このライブラリはクラスとプロトコルの数が多く、また動作には正しく参照を設定する必要があるため、
正しいオブジェクトグラフを作るためにはそれなりにヘッダーを読み込まなければならない.
実際、グラフを精密にコントロールしなければいけないような、トリッキーな事をする時はそれをおすすめする.
（複雑でトリッキーな事をなんでも簡単にしてくれる魔法のライブラリなんてあるわけがない！）

とはいえ、普通のグラフを作る分には、複雑すぎる事も確かなので、FMChartConfiguratorというクラスが
用意されている. 普通の事は一通りできるし、サンプルアプリ(300行程度のswiftコード)もそれを使って書かれている.
中身はHealthKitから歩数・体重・最低最高血圧を読んで表示するだけだが、見れば一通りのやり方がわかるはずである.
またより低レベルなコンポーネントの使い方も、FMChartConfiguratorのソースが自体が、シナリオ毎の解説となるはずだ.


まずはMetalChartDevのViewController.swiftを見て欲しい.
データ空間を作り、変換規則(range決定規則)を作り、データの入れ物(series)を用意し、データの見せ方を決め(Line,Bar,etc...)、
UI操作と変換規則を結びつけ、空間と結びついた軸をアタッチし、軸にラベルをつけているだけである.
この中に「よろしくやってくれ」的な記述はほぼないので冗長に見えるかもしれないが、グラフとはそもそもConfigurationの塊である.
コントロールの粒度を細かく保とうとした場合、おそらくこれより短くはならないはずである.





5. 補足事項

5.1 範囲制御について

写像（表示範囲）の制御に関して、コアクラスでは一切の制約を加えない。
(1)のクラス自体がフラグなどを全く持たず、能動的にはほぼ何もしない、ほぼPlainなオブジェクト（ただしバッファへの書き込みを行う）だからである。
これは「画面表示はどの値に基づいているのか」をシンプルにするために必須である。複雑なロジックはこのオブジェクトを操作するものとして定義されるべきである。
そのため、データやユーザ操作に応じて範囲を制御するための手段は、切り離されたクラス(FMProjectionUpdater)として定義されている。

このFMProjectionUpdaterは複数のFMRangeFilter（長さ制限、データ欠損時のデフォルト値、データに対するパディングの付加等）を
パイプライン状につなげて１軸の表示範囲(FMDimensionalProjection)を決定する。そしてこのクラスに、ユーザの操作を反映するためのFilterを追加することで
Panning等のユーザ操作を可能にしている。
それぞれのFilterがパラメータに対しどう振る舞うかはヘッダに記述があるが、各実装はせいぜい20行程度なので、見た方が早い.

また、移動量などのステートはRestriction自体ではなく、管理用のクラス(FMGestureInterpreter)が保持し、それを参照するようになっている。
ただし、FMProjectionUpdaterは外部から指示されない限りは範囲をアップデートしない（すべきでない）ため、FMInteractionプロトコルと
ブロック実装クラスを用いて、ステート変更時にトリガーしてやる必要がある。

このあたりの煩雑な手続きは、
[FMSimpleBlockInteraction connectUpdaters: toInterpreter: orientations]
で省略できる.



5.2 軸ラベルの既存実装に関して

・既存実装のFMAxisLabel は CoreText -> CGBitmapContext -> MTLTexture -> 四角形　という形で実装されている.
　そのため利用にはCoreText、CoreGraphicsが必要である。

・当該実装を可能にするための仕組みはコアクラスには存在していないため、FMAxisへの付加機能として実装した。

・必須の機能でないものをデフォルトで強要するのはポリシーに反する（かつ描画バッファサイズの問題もあり、難しい）ので、
　ラベルの描画には手動でのセットアップを必要とする。

・全てのラベルが毎フレーム更新されるような場合（普通はないが、ユーザ操作等でメモリ位置がずれる場合）CPUに負荷がかかるため、
　機種やその他負荷によっては60fpsを切る可能性がある。折れ線等他のパーツは点数が増えてもGPU負荷が増えるだけなので競合はしないが、
　アプリ内の他の処理を阻害する事は変わらないので、可能ならば避けるべきである。



5.3 アニメーション実装

今の所アニメーション実装は非常に貧相である。
インタフェースとしては値のブレンディング、ローディングアニメーション、属性（色や大きさ）のアニメーションなど、
かなり多くのことを視野に入れたものになっているが、凝ったアニメーションを「効率的に」かつ「スマートに」実装するためには、
かなりの労力を要すると思われる。
特にアニメーションのコンフリクト（同時実行不可能な複数のアニメーションの衝突）時の解消は、
種類が増えれば増えるほど困難になると思われる。

ただしこれもコアコンポーネントではないし、デフォルトで提供されている実装は全部で300行にもいかない程度なので、
独自実装はそう難しくないはずではある. 実装の際にはFMGestureInterpreterがpanアニメーションの実装を
持っている事に注意する事.



5.4 デプステストを利用する場合

デプステストを利用するシェーダとそれを利用するクラスをアタッチメント・系列として定義する場合、
同様の描画クラス全てに対して利用可能なデプス値の範囲を割り当てる必要がある。
この手続きはFMDepthClientを同時に実装するFMRenderableとFMAttachmentの実装クラスに対して適用される。
また、描画順はデプス値が小さいものから大きいものの順序で行われ、開始点のデプス値は0でる。

ただしデフォルト実装であるFMPlotAreaはこれをさらに拡張して、FMPlotRectClientを実装する
系列やアタッチメントに対し、デプス値によるプロット領域マスクを提供している。
詳細は実装を見て欲しい.



5.5 意図せずGPUリソースを消費する設定

・太い幅の線の描画
フラグメントシェーダへの負荷は、太さに対して（およそ）線形に増加する。
1K以上のデータを描画する際に太い線を用いると、かなりリソースを圧迫する事は理解しておくべきである。
実際にiPod touch 6g、デバッグ実行、描画点数が4K点、実際の可視範囲が2K弱の折れ線系列２つを描画した場合、太さ3、5でのGPUフレーム時間は各々で8.6±0.3ms, 10.8±0.3ms程度、
折れ線を描画しない場合は大体1.5ms程度である事から、かなりの差がある事がわかる.
（実際2K点など小さな画面領域の中で描画する場合はほぼ潰れてしまうので、細くせざるを得ないとは思うが）
逆に、256ポイントのデータ2つ程度なら、幅を落としたところで目に見える性能の変化はない.

