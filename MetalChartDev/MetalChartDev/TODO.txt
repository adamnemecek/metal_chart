

・ラベル描画用のデリゲートとステートの提供
・アニメーション

ラベルの問題もやり方を考えればまぁなんとかなる。デリゲート側を実装するのは骨が折れそうだが。
というか、デフォルト実装をしないとどういうインタフェースが良いか分からんよな。
問題はアニメーション。効率的な方法でやろうと思うと、頂点シェーダ数が倍に跳ね上がる。
あるいは共通の方法をもってフラグで切り替えられる様にするか。
ただ頂点へのアクセス量は多分倍になるだろうとは思う。ブランチを避けつつ余計なメモリアクセスを省く方法はあるかって
いう問題だ・・・いやぁないな。まぁ頂点シェーダじゃ大して負荷も増えないだろうとは思うが。

さて、頂点データを２つ受け取ってアニメーションする方法の話だが、この場合やり方は幾つかある。
CoreAnimation方式で現在地をターゲットに近い様に書き換えていくやり方、そして２つをブレンドしていくやり方の２つ。
metalがcomputeシェーダをサポートして、結果の書き戻しを許容している関係上、前者の方式でのアニメーションは
別の仕組みを使って頂点データを書き換えるやり方が最も効率的で他のコンポーネントに影響を与えないという結論になる。

この辺りはどう考えても前者が取るべき方法である。
どちらもあればあったで便利かもしれないが、後者のやり方は実際に適用するとそれなりにまずい影響がでる。
それにコード的にも完了した時点ですげ替える処理が必要になったりでとにかく不恰好でナイーブなやり方。

前者の方法の問題点は、以下の様になる。
・ターゲットの頂点データを格納するバッファを解放したり確保したりはそれなりにコストがかかる（と言われてる）
・誰がそのComputeシェーダを呼び出すのか。 -> attachemtはあくまでRenderComanndEncoderなので、ちょっと無理.

逆に言えば、これらの問題を解決する事ができさえすれば、実装をしない理由は無くなる。
まず前提条件として、どんな仕組みを容易してComputeShaderを呼び出すか。
実際フレームと同期する必要はないが、このブロックの中で処理してしまうのが最も簡単ではある。
つまり、実装の一例として、あの中で処理する事を許容するのが良いだろう。

ComputeCommandEncoderは単体で使う方が良さそうな事もあり、これを発行するもとになるCommandBufferに
アクセスできる様な方法を確立しておくのが良いだろう。
あと直接ディスパッチするオブジェクトは直接使わず、もっと独立して捌けるように作ったあと、
ラップしてprotocolを実装するのが良い。

後は、MetalChart自体がそのためのコレクションを持ってしまって良いのかっていう事。
ブロックで単体で処理を追加する事自体は可能だが、animationのディスパッチをやるコンポネントを
その扱いにするのは正しいのかどうか。かといって個別に追加するのはあり得ない。
どう考えてもアニメーションは仕組みだと思う。
（いや切り離して単独で構成できるのならそれはそれでいいんだが、かなり立ち位置の微妙なパーツではある）

アニメーションをディスパッチするためのコンテナ自体は割と容易に設計できる。
これとチャートとの関係こそが問題だ。
少なくとも、MetalChart側でCommandBufferを露出するタイミングが必要なのだ。
しかも一つブロックを受け取れるようにするだけでは、関係をサポートする事はとてもできない。
かといって新しい配列を持ってコントロールできるようになんてそれこそキリがない。

AttachementをMetalChartがコントロールするのはなんらおかしくない。なぜなら属するものだからだ。
ただ、アニメーションは全く別だし、コンピュートシェーダを含むその他のコンポーネントはあまりに
自由すぎる。これをコントロールするためにMetalChartがコードを容易するなんて馬鹿げている。

いや、そもそも描画用に必要だから用意したバッファに対するフックって何よ？って話だよな。
でも必要のないコンポネントをコアに組み込むのも間違っている。
だから、ディスパッチャ自体がプロトコルを実装しつつ、フックを複数コントロールできるような
実装クラスを用意して、もう一段階下げるという選択肢も追加するのが最も理想形に近い。

ディスパッチャをどんな形（モデル）にするか。
実際にコマンドを発行するのはプロトコル形式。
ディスパッチャ自体は中身については関与しない。
コンテナの役割、持続性の管理、進行度の管理などを行う。

ただし、アニメーションは種類と対象によってはコンフリクトを起こす。
このハンドリングをどうするか。プロトコル自体に各々事前条件をチェックして、それに対する回避策を
用意できるようにする。コンテナに細かいロジックは記述しない。

この条件のもと、登録時に要求したstartTimestampからコマンドを実行し、最後のコマンド発行が完了したと判断された
（これは戻り値を使うのが良かろうと思われる）後、これを削除する。
これだけのシンプルな動作を繰り返す。

うん、これだけちゃんと仕組みができれば、実装に困る事はないだろう。
次、アニメーションの際の一時領域を確保するコストについて。
一つの回答としては、高が知れてるとか、この領域を確保するのはコンポネント側の責任ではないからとかになる。
回避策なんて本当にごく一部しかなくて、共用の領域を作って使い回すくらいなものだが、
これはありとあらゆる意味で現実的とは言えない。
あと属性をアニメーションするのは、属性側であらかじめ２倍の領域を確保して初めっからターゲット値に向けたアニメーションを
可能にしておくとかは有効かもしれない。というか、実際やるべきなのかもしれない。
ただし、KVCとかはあり得ないのですべての属性がアニメーションしたり、一個一個手で書いたりしなきゃいけない。
実際のところ悩ましい。粒度を考えれば、アニメーションに関しては後者が望ましい。膨大な量になるし
GPUでやる必要すらないが。あーそうか、属性はすべてCPU側でアニメーションするのが正解だ。
だからKVCによるアプローチか自分の手でやるのが良い（KVOは必ずしも効率的ではないし、ベクタなんかは扱えない
可能性がある）

全部CPUに負荷のかかるというか時間のかかる処理は省くべきで、可能ならフレーム処理を始める前に行うべき.
SIMTの構造から考えると別のタスクを同時に走らせられると考えるのはまずい。
ただもう一つの点が、共有メモリからの値の読み出しが、どうしても必要にな・・・らないな。
一つのプロパティに絞ってアニメーションするのなら、開始時に値を持ってこちらに最新の値を書き込んでから
共有領域に書き込めば済む。
問題は如何に全体のコード量を抑えつつ、高速な実行ができる仕組みを作れるかだ。
そのためにはある程度の実装を実際にやらないと、何が必要なのかわからない。

まぁこの辺りのタスクはすべて他と直交してるし、今は放置で問題ない。

