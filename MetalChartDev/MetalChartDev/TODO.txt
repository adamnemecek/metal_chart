

・デプス値を利用したグラデーション導入
　使い方が難しい上にパフォーマンス的なインパクトがでかい。コードの管理も難しい。
　ほとんど遊びのレベルになる
　-> 自由度の高さを考えると、グラデーションではなくUIImageを使った方法が良いと思われる.
　　　またAttachmentにするとSeriesの間に挟む事ができないので、Interfaceに難がある.

・３次デカルト系 ... まぁ色々大変だからね. MVP行列もいるし、まず第一どうやってデータ表示するのかだし

・MTKViewでも関係ない
　一定FPSにして、FPSを変えても関係ない
　特によく画面回転で起きる事が多い、
　 今の所最低でも1回回転を挟んだあと？な気がするが、直接的にはスクロールでも出ているように見えた
　だがMTKViewでdrawableのサイズのハンドリングをしている以上、問題はそこではないと思われる。
　・・・そういえばMetalChartの中で、わざわざviewのサイズとってる所あったな。でもあれは確か、
　なにか別のabortかなんかで発覚してて、ちょっと違うって事なんだろうか？
　drawableSizeを変えなくても、やはり起きている。
　次はシェーダを変更してみる。
　-> 今の所バグが確認できず. これが現象も合わせて考えると一番可能性が高い事は確実っぽい.
　　　バグが出ていた時、使われていたのは、[AttributedPoint, AttributedBar, AttributedLine]、逆に安全が確認されてるのは[Bar]という事になる.
　-> もしかしたら直ったかもしれない. shaderですらなく、pipelineStateとか問題だった可能性が出てきた. 特にshaderはなにもいじってないはずなのだが、正直よくわからない.
　-> どういう事かわからないが、sampleCountで明らかな差が出ている. 2にすると今のところ１度も再現していないが1だと100%出る.
　　　そしてなぜか、GPU不可が両者で変化しない. 実はこれが一番不可解である. そんな訳ねぇ. 絶対何かバグってる.
　この問題は不可解な事が多すぎる。一旦は忘れよう。（そういえば、初期はちゃんとsampleCountに応じて不可変わってたはずだよな・・・なぜだ？）

・MTKViewがsetNeedsDisplayで思うように振舞わないのは、そもそも内部ループを止めているかららしい.
　多分ドローコールは終わってるんだがセマフォで止められてるタイミングだろうと思われる。ちょっと挙動としては度し難いな。
　-> 結局一旦はFMMetalViewで統一する. MTKView使うメリットマジでねぇ.

・さて、ドキュメントを整備している時に気付いた、FMAxis, FMAxisLabel の共有問題.
本来的に言えば、軸をシェアする目的なんて、ラベルをシェアする事以外にはない。
ただし、ラベルをシェアするためにはFMUniformAxisConfigurationは単一インスタンス、かつ軸方向にぶれてはいけない。
このあたり、正しく記述ができるなら、別に今のままで問題ない。そして軸を共有する時、それ以外の方法で整合性を保つ事は100%不可.
あともう一点、

・英語ドキュメント作成中、どうしても章立て（というか何を書くべきか）がはっきりしないので整理する

　1. 極力ヘッダを読めばわかることは割愛する -> ヘッダやクラス定義参照を用いる
　2. 全体の構成と考え方を理解してもらうため、コンセプトの章はきちんと書く.
　3. 何がしたいか、のシナリオ毎にサブセクションを立てて、そこに案内板の役割をさせる.

・サンプルコードをSwiftで書くと逆にまどろっこしい（し効率悪いんでは？という気がしてくる）
・両端のマージンを削るともうちょっとそれっぽくなるかも
・割と真剣にトリプルバッファリングとか、setVertexBytesとか使うことを検討してみてもいいのかもしれない（GPU Frame Timeによる）
　ただしこの場合でも、テクスチャの問題は解決しないし、まずトリプルバッファリングで以下のパーツがどう振る舞うかについて完全にイメージする必要がある
　・ProjectionBuffer -> これはそもそも全てのdim/space依存グラフで統一して使える排他が必要、というより、キャプチャ的仕組みが必要かもしれない


とりあえず、Nibで決まった名前で書けない問題は継承で解決できるが、その場合にはキャストが必要になる箇所がいくつかある。
また、実際には今のヘッダの仕組みでは、うまく対応できない。
確かマクロ定義では外部に持ち出せなかった経緯があるので、これは・・・違うな、あのヘッダでマクロ定義すりゃええのか.



