// This text file is not a part of framework documentation, please ignore and do not modify.

・デプス値を利用したグラデーション導入
　使い方が難しい上にパフォーマンス的なインパクトがでかい。コードの管理も難しい。
　ほとんど遊びのレベルになる
　-> 自由度の高さを考えると、グラデーションではなくUIImageを使った方法が良いと思われる.
　　　またAttachmentにするとSeriesの間に挟む事ができないので、Interfaceに難がある.

・MTKViewでも関係ない
　一定FPSにして、FPSを変えても関係ない
　特によく画面回転で起きる事が多い、
　 今の所最低でも1回回転を挟んだあと？な気がするが、直接的にはスクロールでも出ているように見えた
　だがMTKViewでdrawableのサイズのハンドリングをしている以上、問題はそこではないと思われる。
　・・・そういえばMetalChartの中で、わざわざviewのサイズとってる所あったな。でもあれは確か、
　なにか別のabortかなんかで発覚してて、ちょっと違うって事なんだろうか？
　drawableSizeを変えなくても、やはり起きている。
　-> どういう事かわからないが、sampleCountで明らかな差が出ている. 2にすると今のところ１度も再現していないが1だと100%出る.
　　　そしてなぜか、GPU不可が両者で変化しない. 実はこれが一番不可解である. そんな訳ねぇ. 絶対何かバグってる.
　この問題は不可解な事が多すぎる。一旦は忘れよう。（そういえば、初期はちゃんとsampleCountに応じて負荷変わってたはずだよな・・・なぜだ？）

・スクロールが止まる事がある（繰り返しスワイプしてると時折手を離したタイミングで止まる）
　-> どうもFMGestureBeginのあと、FMGestureEndが来ない事があるらしい。
　　　正確には、dispatcherはすべてのイベントを発行しているが、ハンドラーが何かしらの理由で持ってこれを弾いているとなる.
　　　というか、そもそもなぜディスパッチャが全て配信を終えたあとにこれがくる？順序の問題か？
　　　-> 本当の原因はタップで止まるようにした事が原因だったらしく、一瞬のタッチでGestureRecognizerは発火しないがhandlerは別経路で受けとってとまるパターンが存在する。
　　　　　つまり、キャンセルされたジェスチャを拾ってる事が原因らしい。（というか、そもそもそもがキャンセルすらされていないというね.）
　　　　　なので、これはこれでFMGestureRecognizer側にちゃんと手を入れる必要がある.


・根本的な所で言うと、ユーザ操作によって変更をうけるオブジェクトはCPUサイドのみを持ち、GPU側と結び付く所でのみ値のコピーが起きるべきだと思う。
　そしてその間のみがwrite-lockを受けるべきだ。writeに関してだって、atomicな書き込みが用意されているのが理想だしな。
・複数のChartオブジェクトからの利用に耐えるように作るには、「writeロック」「アトミックな反映」「全体としての整合性を保つための仕組み」
　が必要となる。write-lockとatomicな反映は、言って見ればreadをブロックしないトランザクションのようなものだ。
　そしてその間の変更で全体としての整合性を保つには、トランザクションを伝搬するための非常に複雑な仕組みを要する.

・まぁまずはサンプルの方を変えるか、今のままだと古いデバイスで高負荷をかける事ができない。

・Logarithmicはちゃんと作った方がいい. ただまぁ、それは軸単位でコントロールできるべきだし、値の変換ができればそれでいいんだけど、
　問題は軸描画とマッピングとが分かれてるっていう事なんだよね. どう考えるのが良いのか・・・今の仕組みというか考え方だと結構辛そうだな、
　overhaulしないとまともにメンテ可能な形式にはならなさそうだ。いやぁまぁもともとガッツリと紐付ける形でAxisを定義したし、他の形式で使う事は
　考えてなかったけど、これならまぁ

