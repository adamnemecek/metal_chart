

・ラベル描画用のデリゲートとステートの提供
・アニメーション

ラベルの問題もやり方を考えればまぁなんとかなる。デリゲート側を実装するのは骨が折れそうだが。
というか、デフォルト実装をしないとどういうインタフェースが良いか分からんよな。
問題はアニメーション。効率的な方法でやろうと思うと、頂点シェーダ数が倍に跳ね上がる。
あるいは共通の方法をもってフラグで切り替えられる様にするか。
ただ頂点へのアクセス量は多分倍になるだろうとは思う。ブランチを避けつつ余計なメモリアクセスを省く方法はあるかって
いう問題だ・・・いやぁないな。まぁ頂点シェーダじゃ大して負荷も増えないだろうとは思うが。

さて、頂点データを２つ受け取ってアニメーションする方法の話だが、この場合やり方は幾つかある。
CoreAnimation方式で現在地をターゲットに近い様に書き換えていくやり方、そして２つをブレンドしていくやり方の２つ。
metalがcomputeシェーダをサポートして、結果の書き戻しを許容している関係上、前者の方式でのアニメーションは
別の仕組みを使って頂点データを書き換えるやり方が最も効率的で他のコンポーネントに影響を与えないという結論になる。

この辺りはどう考えても前者が取るべき方法である。
どちらもあればあったで便利かもしれないが、後者のやり方は実際に適用するとそれなりにまずい影響がでる。
それにコード的にも完了した時点ですげ替える処理が必要になったりでとにかく不恰好でナイーブなやり方。

前者の方法の問題点は、以下の様になる。
・ターゲットの頂点データを格納するバッファを解放したり確保したりはそれなりにコストがかかる（と言われてる）
・誰がそのComputeシェーダを呼び出すのか。 -> attachemtはあくまでRenderComanndEncoderなので、ちょっと無理.

逆に言えば、これらの問題を解決する事ができさえすれば、実装をしない理由は無くなる。
まず前提条件として、どんな仕組みを容易してComputeShaderを呼び出すか。
実際フレームと同期する必要はないが、このブロックの中で処理してしまうのが最も簡単ではある。
つまり、実装の一例として、あの中で処理する事を許容するのが良いだろう。

ComputeCommandEncoderは単体で使う方が良さそうな事もあり、これを発行するもとになるCommandBufferに
アクセスできる様な方法を確立しておくのが良いだろう。
あと直接ディスパッチするオブジェクトは直接使わず、もっと独立して捌けるように作ったあと、
ラップしてprotocolを実装するのが良い。

後は、MetalChart自体がそのためのコレクションを持ってしまって良いのかっていう事。
ブロックで単体で処理を追加する事自体は可能だが、animationのディスパッチをやるコンポネントを
その扱いにするのは正しいのかどうか。かといって個別に追加するのはあり得ない。
どう考えてもアニメーションは仕組みだと思う。
（いや切り離して単独で構成できるのならそれはそれでいいんだが、かなり立ち位置の微妙なパーツではある）

アニメーションをディスパッチするためのコンテナ自体は割と容易に設計できる。
これとチャートとの関係こそが問題だ。
少なくとも、MetalChart側でCommandBufferを露出するタイミングが必要なのだ。
しかも一つブロックを受け取れるようにするだけでは、関係をサポートする事はとてもできない。
かといって新しい配列を持ってコントロールできるようになんてそれこそキリがない。

AttachementをMetalChartがコントロールするのはなんらおかしくない。なぜなら属するものだからだ。
ただ、アニメーションは全く別だし、コンピュートシェーダを含むその他のコンポーネントはあまりに
自由すぎる。これをコントロールするためにMetalChartがコードを容易するなんて馬鹿げている。

いや、そもそも描画用に必要だから用意したバッファに対するフックって何よ？って話だよな。
でも必要のないコンポネントをコアに組み込むのも間違っている。
だから、ディスパッチャ自体がプロトコルを実装しつつ、フックを複数コントロールできるような
実装クラスを用意して、もう一段階下げるという選択肢も追加するのが最も理想形に近い。

ディスパッチャをどんな形（モデル）にするか。
実際にコマンドを発行するのはプロトコル形式。
ディスパッチャ自体は中身については関与しない。
コンテナの役割、持続性の管理、進行度の管理などを行う。

ただし、アニメーションは種類と対象によってはコンフリクトを起こす。
このハンドリングをどうするか。プロトコル自体に各々事前条件をチェックして、それに対する回避策を
用意できるようにする。コンテナに細かいロジックは記述しない。

この条件のもと、登録時に要求したstartTimestampからコマンドを実行し、最後のコマンド発行が完了したと判断された
（これは戻り値を使うのが良かろうと思われる）後、これを削除する。
これだけのシンプルな動作を繰り返す。

うん、これだけちゃんと仕組みができれば、実装に困る事はないだろう。
次、アニメーションの際の一時領域を確保するコストについて。
一つの回答としては、高が知れてるとか、この領域を確保するのはコンポネント側の責任ではないからとかになる。
回避策なんて本当にごく一部しかなくて、共用の領域を作って使い回すくらいなものだが、
これはありとあらゆる意味で現実的とは言えない。
あと属性をアニメーションするのは、属性側であらかじめ２倍の領域を確保して初めっからターゲット値に向けたアニメーションを
可能にしておくとかは有効かもしれない。というか、実際やるべきなのかもしれない。
ただし、KVCとかはあり得ないのですべての属性がアニメーションしたり、一個一個手で書いたりしなきゃいけない。
実際のところ悩ましい。粒度を考えれば、アニメーションに関しては後者が望ましい。膨大な量になるし
GPUでやる必要すらないが。あーそうか、属性はすべてCPU側でアニメーションするのが正解だ。
だからKVCによるアプローチか自分の手でやるのが良い（KVOは必ずしも効率的ではないし、ベクタなんかは扱えない
可能性がある）

全部CPUに負荷のかかるというか時間のかかる処理は省くべきで、可能ならフレーム処理を始める前に行うべき.
SIMTの構造から考えると別のタスクを同時に走らせられると考えるのはまずい。
ただもう一つの点が、共有メモリからの値の読み出しが、どうしても必要にな・・・らないな。
一つのプロパティに絞ってアニメーションするのなら、開始時に値を持ってこちらに最新の値を書き込んでから
共有領域に書き込めば済む。
問題は如何に全体のコード量を抑えつつ、高速な実行ができる仕組みを作れるかだ。
そのためにはある程度の実装を実際にやらないと、何が必要なのかわからない。

まぁこの辺りのタスクはすべて他と直交してるし、今は放置で問題ない。

Animation自体に必要なのは、

・Animation自体
・他のアニメーションとの調停
・最低でもフレームのインデックス

現在時間はどうやって把握するのがいいかって話だが。
絶対時間を使って云々とか気が狂ってるので・・・いや、引数はそれでもいいのか。
Animation側で処理できれば。

で、一通りの簡単な実装はした。どのくらい使えるのかは知らん。
一回ちゃんと使ってみたい。
使ってみた。本当に何も心配しなくてよいレベルで動いた。
多少はTypical Useを意識して便利な実装クラスを用意したほうがいいかもしれないが、
まぁ実際のところほっとんどBlockAnimationでどうとでもできるレベル。

あと、バッファへの書き込みの同期が取れてないのは、ちゃんとデバッグする。
なんだろ、ブリッツかな。
んーそもそも何が原因になってるかわからん・・・.

・・・あぁ書き込みの反映が遅い、よりはもっと現実的な原因がある。
つまり次のフレームが先に点を追加してしまっているパターン。
かと思ったが、同期では解決しない。
となると、ガチでGPUメモリへの書き込みが間に合ってないって事になる。
・・・どうやらプログラムの整合性云々ではないらしいな。
・・・かと思ったけど、絶ってぇちげぇ。
さすがに２サイクル先に書き込んでるのが間に合わないとかありえあいだろ。
なんっかおかしい。普通の機能拡張より、はるかに面倒だ。
実際のところ、ドキュメンテーションにはちゃんと書き込みは反映されるってかいてある。
それが示すところは、何かしらの理由で、
info.offset / count と実際に書き込まれたデータの間で何かしらの不整合が発生している、
という事。一番理解できないのは、すでに書き込む位置をずらしてある、という事。
うんまぁ家で考える。

じゃあ、いよいよ最後のラベル描画について。
これが終わると、いよいよ他にやる事がなくなる。
まぁでも、やるしかないか。
実装系は家で作るにしても、インタフェースくらいはね。
まずまぁ実装系の選択肢について。
CoreText / CoreGraphics / UIKit
まぁこんなところだ。

ただ、ラベルを乗せるにしても何にしても、その位置が確定できない（本当に、Metalがテキストサポートできたら
話は楽なんだが）。
んーどしよっかな。
まぁCoreTextを利用するしかないか。
でもビュー自体が別になるとクソかったるいから、テクスチャへの描画ができるとすごい楽なんだが
（あとまぁ使い回しも聞くし）、この辺りを先に整備する必要があるって事かしらね。

うん、実際のところ、CoreTextを使うのが一番ありえないっぽい。
直接書き込む方法を確立するか、あるいはUILabelを使う方法が一番わかりやすいっぽい。
ただ、どうやってもコンテナとなるビューと別れてしまうので、使い方が難しいし、
かなり制限も多い。

あーだめだ、これもう完全にsigned-distance fieldsを使わないとそれらしい形にならん。
いやっありえん。なんとかプラットフォーム側でサポートしてくんないかな・・・。



